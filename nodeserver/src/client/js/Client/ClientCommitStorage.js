define(['commonUtil',"core/lib/sha1",'js/Client/ClientStorage','core/assert'],
    function(commonUtil,SHA1,cStorage,ASSERT){
        'use strict';
        var BID = "*";
        var ClientCommitStorage = function(options){
            var actualbranchinfo = null,
                currentbranchname = null,
                currentupdfunc = null,
                storage = new cStorage(options);

            var getBranches = function(callback){
                ASSERT(storage.opened());
                storage.find({type:"branch"},function(err,nodes){
                    if(err){
                        callback(err);
                    } else {
                        if(nodes && nodes.length>0){
                            var branches = [];
                            for(var i=0;i<nodes.length;i++){
                                branches.push(nodes[i].name);
                            }
                            callback(null,branches);
                        } else {
                            callback("no branches were found");
                        }
                    }
                });
            };

            var _updatefunc = function(data){
                if(currentupdfunc){
                    $('#maintitlespan').html(options.projectinfo+"@"+currentbranchname+"@"+data);
                    currentupdfunc(data);
                }
            };
            var poll = function(node){
                ASSERT(storage.opened());
                if(currentupdfunc){
                    storage.requestPoll(BID+currentbranchname,poll);
                    actualbranchinfo = node;
                    _updatefunc(node.root);
                }
            };

            var selectBranch = function(branchname,updfunc,simplecallback){
                ASSERT(storage.opened());
                currentbranchname = branchname;
                if(updfunc){
                    currentupdfunc = updfunc;
                }
                storage.requestPoll(BID+branchname,poll);
                storage.load(BID+branchname,function(err,node){
                    if(!err && node){
                        actualbranchinfo = node;
                        _updatefunc(node.root);
                        if(simplecallback){
                            simplecallback(null);
                        }
                    } else {
                        if(node){
                            console.log("something wrong with branch +"+err);
                            if(simplecallback){
                                simplecallback(err);
                            }
                        } else {
                            console.log("no given branch...");
                            if(simplecallback){
                                simplecallback(err);
                            }
                            //TODO temporary hacking to creat master branch from the old version of database
                            storage.load("***root***",function(err,roots){
                                if(err || roots === null || roots === undefined || roots.value.length <1){
                                    console.log("not a convertable datacollection -> really no branch...");
                                } else {
                                    var initmainbranch = {
                                        _id     : "*master",
                                        root    : roots.value[roots.value.length-1],
                                        oldroot : roots.value[roots.value.length-1],
                                        parents : [],
                                        updates : [],
                                        start   : commonUtil.timestamp(),
                                        end     : null,
                                        message : "generated by ClientCommitStorage as a conversion",
                                        name    : "master",
                                        type    : "branch"
                                    };
                                    storage.save(initmainbranch,function(err){
                                        if(err){
                                            console.log("something wrong with conversion, try again ("+err+")");
                                        } else {
                                            storage.remove("***root***",function(err){
                                                if(err){
                                                    console.log("old root was not removed properly, please do it by hand");
                                                }
                                                selectBranch(branchname,updfunc);
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    }
                });
            };

            var updateRoot = function(rootkey,callback){
                ASSERT(storage.opened());
                if(actualbranchinfo){
                    var myroot = JSON.parse(JSON.stringify(actualbranchinfo));
                    myroot.oldroot = myroot.root;
                    myroot.root = rootkey;
                    storage.save(myroot,function(err){
                        if(err){
                            //TODO popup for new branch
                            switch(err){
                                case "invalid root cannot be saved!!!":
                                    var newbranchid = commonUtil.guid()
                                    myroot["_id"] = BID+newbranchid;
                                    myroot.name = newbranchid;
                                    storage.save(myroot,function(err){
                                        if(err){
                                            callback(err);
                                        } else {
                                            selectBranch(newbranchid,null,function(err){
                                                if(err){
                                                    console.log("cannot create the new branch...");
                                                } else {
                                                    callback(null);
                                                }
                                            });
                                        }
                                    });
                                    break;
                                default:
                                    callback(err);
                                    break;
                            }
                        } else {
                            actualbranchinfo = myroot;
                            callback(null);
                        }
                    });
                } else {
                    callback("no branch is used");
                }
            };

            var commit = function(commitobjextension,callback){
                callback = callback || function(err){};
                ASSERT(storage.opened());
                var mycommit = JSON.parse(JSON.stringify(actualbranchinfo));
                var branchname = mycommit['_id'];
                mycommit['_id'] = false;
                mycommit.type = 'commit';
                mycommit.end = commonUtil.timestamp();
                delete mycommit.oldroot;
                //checking the incoming extensions from user
                mycommit.message = commitobjextension.message || mycommit.message;

                var key = '#' + SHA1(JSON.stringify(mycommit));
                mycommit['_id'] = key;

                storage.save(mycommit,function(err){
                    if(err){
                        callback(err);
                    } else {
                        var newbranchhead = {
                            _id     : branchname,
                            root    : mycommit.root,
                            oldroot : mycommit.root,
                            parents : [key],
                            updates : [],
                            start   : commonUtil.timestamp(),
                            end     : null,
                            message : "",
                            name    : mycommit.name,
                            type    : "branch"
                        };
                        storage.save(newbranchhead,function(err){
                            if(err){
                                callback(err);
                            } else {
                                actualbranchinfo = newbranchhead;
                                callback(null);
                            }
                        });
                    }
                });
            };

            var getCommits = function(callback){
                ASSERT(storage.opened());
                storage.find({type:"commit"},function(err,nodes){
                    if(err){
                        callback(err);
                    } else {
                        if(nodes && nodes.length>0){
                            var branches = [];
                            for(var i=0;i<nodes.length;i++){
                                branches.push(nodes[i]['_id']);
                            }
                            callback(null,branches);
                        } else {
                            callback("no branches were found");
                        }
                    }
                });
            };

            var loadCommit = function(commitkey){
                ASSERT(storage.opened());
                storage.load(commitkey,function(err,commit){
                    if(err){
                        /*TODO - na itt mi van*/

                    } else {

                        var newbranchhead = {
                            _id     : BID+commit.name,
                            root    : commit.root,
                            oldroot : commit.root,
                            parents : ["#"+commitkey],
                            updates : [],
                            start   : commonUtil.timestamp(),
                            end     : null,
                            message : "",
                            name    : commit.name,
                            type    : "branch"
                        };

                        actualbranchinfo = newbranchhead;
                        _updatefunc(commit.root);
                    }
                });
            };

            return {
                //relayed storage functions
                open          : storage.open,
                opened        : storage.opened,
                close         : storage.close,
                KEYNAME       : storage.KEYNAME,
                load          : storage.load,
                save          : storage.save,
                remove        : storage.remove,
                dumpAll       : storage.dumpAll,
                removeAll     : storage.removeAll,
                searchId      : storage.searchId,
                whenAvailable : storage.whenAvailable,
                fsync         : storage.fsync,
                find          : storage.find,
                requestPoll   : storage.requestPoll,
                //additional functions to storage
                selectBranch           : selectBranch,
                updateRoot             : updateRoot,
                commit                 : commit,
                getBranches            : getBranches,
                getCommits             : getCommits,
                loadCommit             : loadCommit
            }
        };

        return ClientCommitStorage;
    });